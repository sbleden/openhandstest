{"ast":null,"code":"import * as i0 from \"@angular/core\";\nconst _c0 = [\"gameCanvas\"];\nexport class AppComponent {\n  constructor() {\n    this.snake = [];\n    this.food = {\n      x: 0,\n      y: 0\n    };\n    this.direction = 'right';\n    this.gridSize = 20;\n    this.score = 0;\n  }\n  ngOnInit() {\n    this.ctx = this.canvas.nativeElement.getContext('2d');\n    this.startGame();\n  }\n  startGame() {\n    // Initialize snake\n    this.snake = [{\n      x: 3,\n      y: 1\n    }, {\n      x: 2,\n      y: 1\n    }, {\n      x: 1,\n      y: 1\n    }];\n    this.score = 0;\n    this.direction = 'right';\n    this.generateFood();\n    if (this.gameInterval) {\n      clearInterval(this.gameInterval);\n    }\n    this.gameInterval = setInterval(() => this.gameLoop(), 150);\n  }\n  handleKeyDown(event) {\n    switch (event.key) {\n      case 'ArrowUp':\n        if (this.direction !== 'down') this.direction = 'up';\n        break;\n      case 'ArrowDown':\n        if (this.direction !== 'up') this.direction = 'down';\n        break;\n      case 'ArrowLeft':\n        if (this.direction !== 'right') this.direction = 'left';\n        break;\n      case 'ArrowRight':\n        if (this.direction !== 'left') this.direction = 'right';\n        break;\n    }\n  }\n  gameLoop() {\n    const head = {\n      ...this.snake[0]\n    };\n    switch (this.direction) {\n      case 'up':\n        head.y--;\n        break;\n      case 'down':\n        head.y++;\n        break;\n      case 'left':\n        head.x--;\n        break;\n      case 'right':\n        head.x++;\n        break;\n    }\n    // Check collision with walls\n    if (head.x < 0 || head.x >= this.canvas.nativeElement.width / this.gridSize || head.y < 0 || head.y >= this.canvas.nativeElement.height / this.gridSize) {\n      this.startGame();\n      return;\n    }\n    // Check collision with self\n    if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {\n      this.startGame();\n      return;\n    }\n    this.snake.unshift(head);\n    // Check if snake ate food\n    if (head.x === this.food.x && head.y === this.food.y) {\n      this.score += 10;\n      this.generateFood();\n    } else {\n      this.snake.pop();\n    }\n    this.draw();\n  }\n  generateFood() {\n    const maxX = this.canvas.nativeElement.width / this.gridSize - 1;\n    const maxY = this.canvas.nativeElement.height / this.gridSize - 1;\n    do {\n      this.food = {\n        x: Math.floor(Math.random() * maxX),\n        y: Math.floor(Math.random() * maxY)\n      };\n    } while (this.snake.some(segment => segment.x === this.food.x && segment.y === this.food.y));\n  }\n  draw() {\n    const ctx = this.ctx;\n    const canvas = this.canvas.nativeElement;\n    // Clear canvas\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw snake\n    ctx.fillStyle = 'green';\n    this.snake.forEach(segment => {\n      ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);\n    });\n    // Draw food\n    ctx.fillStyle = 'red';\n    ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);\n  }\n  static {\n    this.ɵfac = function AppComponent_Factory(t) {\n      return new (t || AppComponent)();\n    };\n  }\n  static {\n    this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"app-root\"]],\n      viewQuery: function AppComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n        }\n      },\n      hostBindings: function AppComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function AppComponent_keydown_HostBindingHandler($event) {\n            return ctx.handleKeyDown($event);\n          }, false, i0.ɵɵresolveWindow);\n        }\n      },\n      decls: 4,\n      vars: 1,\n      consts: [[\"gameCanvas\", \"\"], [\"width\", \"400\", \"height\", \"400\"]],\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"canvas\", 1, 0);\n          i0.ɵɵelementStart(2, \"div\");\n          i0.ɵɵtext(3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵtextInterpolate1(\"Score: \", ctx.score, \"\");\n        }\n      },\n      styles: [\"canvas[_ngcontent-%COMP%] {\\n      border: 1px solid black;\\n      margin: 20px;\\n    }\\n  \\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0lBQ0k7TUFDRSx1QkFBdUI7TUFDdkIsWUFBWTtJQUNkIiwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgY2FudmFzIHtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgbWFyZ2luOiAyMHB4O1xuICAgIH1cbiAgIl0sInNvdXJjZVJvb3QiOiIifQ== */\"]\n    });\n  }\n}","map":{"version":3,"names":["AppComponent","constructor","snake","food","x","y","direction","gridSize","score","ngOnInit","ctx","canvas","nativeElement","getContext","startGame","generateFood","gameInterval","clearInterval","setInterval","gameLoop","handleKeyDown","event","key","head","width","height","some","segment","unshift","pop","draw","maxX","maxY","Math","floor","random","fillStyle","fillRect","forEach","selectors","viewQuery","AppComponent_Query","rf","i0","ɵɵlistener","AppComponent_keydown_HostBindingHandler","$event","ɵɵresolveWindow","ɵɵelement","ɵɵelementStart","ɵɵtext","ɵɵelementEnd","ɵɵadvance","ɵɵtextInterpolate1"],"sources":["/workspace/openhandstest/snake-game/src/app/app.component.ts"],"sourcesContent":["import { Component, OnInit, ViewChild, ElementRef, HostListener } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <canvas #gameCanvas width=\"400\" height=\"400\"></canvas>\n    <div>Score: {{ score }}</div>\n  `,\n  styles: [`\n    canvas {\n      border: 1px solid black;\n      margin: 20px;\n    }\n  `]\n})\nexport class AppComponent implements OnInit {\n  @ViewChild('gameCanvas', { static: true })\n  canvas!: ElementRef<HTMLCanvasElement>;\n  \n  private ctx!: CanvasRenderingContext2D;\n  private snake: { x: number; y: number }[] = [];\n  private food: { x: number; y: number } = { x: 0, y: 0 };\n  private direction: 'up' | 'down' | 'left' | 'right' = 'right';\n  private gridSize = 20;\n  private gameInterval: any;\n  score = 0;\n\n  ngOnInit() {\n    this.ctx = this.canvas.nativeElement.getContext('2d')!;\n    this.startGame();\n  }\n\n  startGame() {\n    // Initialize snake\n    this.snake = [\n      { x: 3, y: 1 },\n      { x: 2, y: 1 },\n      { x: 1, y: 1 }\n    ];\n    \n    this.score = 0;\n    this.direction = 'right';\n    this.generateFood();\n    \n    if (this.gameInterval) {\n      clearInterval(this.gameInterval);\n    }\n    \n    this.gameInterval = setInterval(() => this.gameLoop(), 150);\n  }\n\n  @HostListener('window:keydown', ['$event'])\n  handleKeyDown(event: KeyboardEvent) {\n    switch (event.key) {\n      case 'ArrowUp':\n        if (this.direction !== 'down') this.direction = 'up';\n        break;\n      case 'ArrowDown':\n        if (this.direction !== 'up') this.direction = 'down';\n        break;\n      case 'ArrowLeft':\n        if (this.direction !== 'right') this.direction = 'left';\n        break;\n      case 'ArrowRight':\n        if (this.direction !== 'left') this.direction = 'right';\n        break;\n    }\n  }\n\n  private gameLoop() {\n    const head = { ...this.snake[0] };\n    \n    switch (this.direction) {\n      case 'up': head.y--; break;\n      case 'down': head.y++; break;\n      case 'left': head.x--; break;\n      case 'right': head.x++; break;\n    }\n\n    // Check collision with walls\n    if (head.x < 0 || head.x >= this.canvas.nativeElement.width / this.gridSize ||\n        head.y < 0 || head.y >= this.canvas.nativeElement.height / this.gridSize) {\n      this.startGame();\n      return;\n    }\n\n    // Check collision with self\n    if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {\n      this.startGame();\n      return;\n    }\n\n    this.snake.unshift(head);\n\n    // Check if snake ate food\n    if (head.x === this.food.x && head.y === this.food.y) {\n      this.score += 10;\n      this.generateFood();\n    } else {\n      this.snake.pop();\n    }\n\n    this.draw();\n  }\n\n  private generateFood() {\n    const maxX = this.canvas.nativeElement.width / this.gridSize - 1;\n    const maxY = this.canvas.nativeElement.height / this.gridSize - 1;\n    \n    do {\n      this.food = {\n        x: Math.floor(Math.random() * maxX),\n        y: Math.floor(Math.random() * maxY)\n      };\n    } while (this.snake.some(segment => \n      segment.x === this.food.x && segment.y === this.food.y));\n  }\n\n  private draw() {\n    const ctx = this.ctx;\n    const canvas = this.canvas.nativeElement;\n    \n    // Clear canvas\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw snake\n    ctx.fillStyle = 'green';\n    this.snake.forEach(segment => {\n      ctx.fillRect(\n        segment.x * this.gridSize,\n        segment.y * this.gridSize,\n        this.gridSize - 2,\n        this.gridSize - 2\n      );\n    });\n\n    // Draw food\n    ctx.fillStyle = 'red';\n    ctx.fillRect(\n      this.food.x * this.gridSize,\n      this.food.y * this.gridSize,\n      this.gridSize - 2,\n      this.gridSize - 2\n    );\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}